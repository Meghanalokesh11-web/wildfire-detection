# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kWK-44ZAP4CaSVikLoKmSBVuN5uFSHRx
"""

import cv2
import numpy as np
from tensorflow.keras.models import load_model, Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.preprocessing.image import ImageDataGenerator
import os

# Load or define the model
def create_model():
    """Creates and compiles the wildfire detection model."""
    model = Sequential()

    # First Convolutional Layer
    model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(100, 100, 3)))
    model.add(MaxPooling2D(2, 2))

    # Second Convolutional Layer
    model.add(Conv2D(64, (3, 3), activation='relu'))
    model.add(MaxPooling2D(2, 2))

    # Third Convolutional Layer
    model.add(Conv2D(128, (3, 3), activation='relu'))
    model.add(MaxPooling2D(2, 2))

    # Flatten the feature maps
    model.add(Flatten())

    # Fully Connected Layer with Dropout for regularization
    model.add(Dense(128, activation='relu'))
    model.add(Dropout(0.5))

    # Output layer with sigmoid activation (binary classification)
    model.add(Dense(1, activation='sigmoid'))

    # Compile the model
    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

    return model

# Create a new model or load an existing one
# If the model is pre-trained, load it; otherwise, create a new one
if os.path.exists("/content/TensorFlow.h5"):
    wildfire_model = load_model("/content/TensorFlow.h5")
else:
    wildfire_model = create_model()

# Preprocess image for model input
def preprocess_image(image_path):
    """Preprocess image to match the model's input requirements."""
    if not os.path.exists(image_path):
        raise FileNotFoundError(f"Image file not found: {image_path}")

    # Load the image
    image = cv2.imread(image_path)
    if image is None:
        raise ValueError(f"Unable to load image from {image_path}. Check the file format or path.")

    # Resize image to the expected size (100x100x3)
    image = cv2.resize(image, (100, 100))  # Model expects 100x100 images with 3 channels
    image = image / 255.0  # Normalize pixel values to [0, 1]
    image = np.expand_dims(image, axis=0)  # Add batch dimension (1, 100, 100, 3)
    return image

# Predict wildfire or no wildfire
def detect_wildfire(image_path, threshold=0.5):
    """Detect wildfire using the pre-trained AI model."""
    processed_image = preprocess_image(image_path)

    # Get raw prediction output
    prediction = wildfire_model.predict(processed_image)

    # Print raw prediction (probabilities)
    print(f"Raw prediction: {prediction}")

    # Now, decide if it's a wildfire or not based on the output
    if prediction[0][0] > threshold:
        return "Wildfire"
    else:
        return "No Wildfire"

# Example to train or predict
def train_model():
    """Train the model with augmented data."""
    # Set up data generators for image augmentation
    train_datagen = ImageDataGenerator(
        rescale=1./255,
        shear_range=0.2,
        zoom_range=0.2,
        horizontal_flip=True
    )

    train_generator = train_datagen.flow_from_directory(
        'path_to_train_data',  # Replace with the path to your training data
        target_size=(100, 100),
        batch_size=32,
        class_mode='binary'
    )

    # Train the model
    wildfire_model.fit(train_generator, epochs=10, steps_per_epoch=100)  # Adjust epochs and steps_per_epoch

    # Save the trained model
    wildfire_model.save("wildfire_detection_model.h5")

# Example Execution
if __name__ == "__main__":
    try:
        # For testing the model with an image
        image_path = "/content/drone_image.jpg"  # Replace with your image file
        wildfire_status = detect_wildfire(image_path, threshold=0.5)  # Use a threshold of 0.5
        print(f"Wildfire Detection: {wildfire_status}")

        # Uncomment to train the model
        # train_model()

    except Exception as e:
        print(f"Error: {e}")